{"meta":{"title":"CHEN.JH","subtitle":null,"description":null,"author":"CHEN.JH","url":"http://yoursite.com","root":"/"},"pages":[{"title":"陈俊豪-网络工程师","date":"2019-05-04T16:00:00.000Z","updated":"2019-05-10T03:35:23.170Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人信息 陈俊豪/男/1990 本科/重庆邮电大学 通信工程 工作时间：2013年起 期望职位：bs软件工程师 期望薪资：税前月薪 &gt; 12k 所在地：重庆-大渡口 关于我 精通前端技术，做过h5游戏，切片，webapp，一直致力于bs前端以及全栈开发，在离职前担任公司前端技术负责人，搭建了基于vue全家桶的前端框架 擅长基于项目情况制定前端架构方案，在架构中技术多样化，可在架构中实现的切面编程，控制反转，文件扫描等技术 有多年.net mvc开发经验，有java spring以及python django的项目经验，因此有多种技术融合的创新想法，通过借鉴其他技术来提供更多的项目方案 个人技博：https://12mg.github.io 联系方式 手机：15215126518 Email：aaroncjh@126.com QQ：2651337436 工作经历 重庆市慧都科技有限公司 （ 2016年 ~ 2019年 ） 全员生产管理系统 前端项目搭建，技术选型，底层架构实现，解决多个前端问题，独立解决表单编辑器等技术难点 北工大IOT监测系统 基于spring boot+mybatis+easyui+第三方地图控件 的分业务模块的全栈开发，负责地图中物联网设备展示以及相关服务端数据接口调用 航天云网管理系统 .net mvc+kendoui 处理基本的人员信息登记，部门层级管理，还有人员任务分配，甘特图展示，文件处理 其他项目 负责维护公司官网开发，专题更新，以及第三方CRM系统的调用接口开发，公司官网为.net开发的 重庆龙学天下 （ 2015年 ~ 2016年 ） 创业型公司，搭建了公司网站，微网页，js特效开发 展示"}],"posts":[{"title":"修饰器与参数","slug":"decovar","date":"2019-05-08T08:13:10.000Z","updated":"2019-05-10T09:53:33.122Z","comments":true,"path":"2019/05/08/decovar/","link":"","permalink":"http://yoursite.com/2019/05/08/decovar/","excerpt":"","text":"在前端切面编程中有个问题，比如做表格批量删除，删除前先判断是否有选中删除的项，如果有，则执行删除，如果无，则执行提示框提示先选择，这时候可以把这个判断切面，函数仅仅执行删除过程但是出现的问题是，切面中需要获取变量值，保留修饰器的特性同时将this的值传进去呢？组件不管是json对象，还是class对象，都无法让外部函数调用组建的this，即使apply也找不到组件对象，这是我采用了泽中的办法，参数值如果为组件变量，则仅仅传入参数Key，通过修饰器内部获取值这是目前的最优解，可能会有特殊情况没考虑，遇到了再修改","categories":[{"name":"前端架构设计","slug":"前端架构设计","permalink":"http://yoursite.com/categories/前端架构设计/"}],"tags":[]},{"title":"对象状态暂存","slug":"transation","date":"2019-05-07T08:13:10.000Z","updated":"2019-05-09T07:30:18.970Z","comments":true,"path":"2019/05/07/transation/","link":"","permalink":"http://yoursite.com/2019/05/07/transation/","excerpt":"","text":"在双向绑定的框架中总会出现这种情况，编译一个绑定对象的表单的时候，取消后需对对象进行还原，实现的原理是基于深拷贝，为了方便使用，对于这一功能封装了一个函数，这个函数可以扩展多种功能，比如验证对象是否发生了变化，而底层使用了Lodash，Lodash并非全局引用，能用es6实现的应尽量使用es6实现，部分数据，对象，字符串的处理上可以使用Lodash123456789imfCancel()&#123; this.isImfModifying=false; this.companyProfile=trans.rollBack(&quot;companyProfile&quot;);&#125;;imfModify()&#123; this.isImfModifying=true; let companyProfile=this.companyProfile; trans.begin(&#123;companyProfile&#125;);&#125;","categories":[{"name":"前端架构设计","slug":"前端架构设计","permalink":"http://yoursite.com/categories/前端架构设计/"}],"tags":[]},{"title":"router处理","slug":"routerSet","date":"2019-05-06T05:58:57.685Z","updated":"2019-05-07T08:15:15.928Z","comments":true,"path":"2019/05/06/routerSet/","link":"","permalink":"http://yoursite.com/2019/05/06/routerSet/","excerpt":"","text":"vue中关于router架构，目前我设计了两种方案，可根据不同的情况搭配。1.中心化，分类打包2.去中心化，整体打包 中心化：常规配置，但应用了按需加载，使单文件分类打包，优点是项目第一次加载快，并且编译出的结果分析性高去中心化：非常规配置，官方提供的功能是通过路由寻找到页面，但页面需在router里面配置一下，导致耦合性低，去中心化是将router配置放在了需加载页面中，不需要创建router配置内容，因此页面可完全独立开，甚至可以根据具体的项目情况，实现默认根据物理路径默认router配置，但暂时无法没想到按需加载的办法 去中心化示例：1@routerDeco(&quot;/CompanyProfile&quot;,&quot;company&quot;,&quot;layout&quot;)","categories":[{"name":"前端架构设计","slug":"前端架构设计","permalink":"http://yoursite.com/categories/前端架构设计/"}],"tags":[]},{"title":"mock处理","slug":"mock","date":"2019-05-04T08:13:10.000Z","updated":"2019-05-09T07:33:13.172Z","comments":true,"path":"2019/05/04/mock/","link":"","permalink":"http://yoursite.com/2019/05/04/mock/","excerpt":"","text":"前面后端分离时，如果服务端未实现接口，可使用mock作为模拟数据使用，为了使mock辅组下更加灵活，我的设计如下：1.封装了统一返回内容，这个尽量与服务端保持一致2.先配置mock的json对象，再实例化mock函数3.根据上一步的类似于配置文件，按需进行mock处理，为了使mock处理更加优雅，使用到修饰器，按需进行加载，不许要mock的请求直接删掉修饰器就可以发送请求 1234@mockDeco(&quot;/kbsystem/user/structure&quot;,&quot;get&quot;)@mockDeco(&quot;/kbsystem/company&quot;,&quot;get&quot;)@mockDeco(&quot;/kbsystem/user&quot;,&quot;get&quot;)export default class companyProfile&#123;&#125; (关于写mocjk配置那块有点抽象，可能需要优化)","categories":[{"name":"前端架构设计","slug":"前端架构设计","permalink":"http://yoursite.com/categories/前端架构设计/"}],"tags":[]},{"title":"技术支持","slug":"support","date":"2019-03-22T10:13:10.000Z","updated":"2019-05-09T07:58:37.692Z","comments":true,"path":"2019/03/22/support/","link":"","permalink":"http://yoursite.com/2019/03/22/support/","excerpt":"","text":"AOP这种模式谁用过谁都觉得可以，近期终于把这方便的东西研究了一下，没想到在js上现在也可以实现其实，js对切面编程本来都有一定的支持性，比如this提升，原本最让人痛苦的地方居然还成为了优势。在前端设计中有这样的应用，1.封装请求方法，2.业务中调用请求方法。但是会遇到这样一个问题，请求方发中每一次请求都会调用UI界面的操作，比如请求中的loading，请求错误的提示，但封装的请求方法应该是纯粹的，不同的项目调用的UI操作代码可能也不一样，如果每一次都重新写的话就臃肿了，如果在这里做到切面呢，简单的思维就是把ui的全局变量放进入，理论上可以实现，但确实不科学，其实最终解决的方法仅仅一个this变量提升就可以搞定，最终如下效果12345this.$Req(&quot;/kbsystem/user/structure&quot;,&quot;get&quot;,null,&#123; success(responseData)&#123; _this.memberDatas=responseData.data.data; &#125;&#125;); 执行以上的方法，便可实现loading UI以及错误回复的UI 其实网上有个关于aop实现的方法，采用扩展function方法，基本类型的扩展有一定的风险性，之前在其他项目里面我也曾今想做基本类型拓展，但是就怕全局变量的污染，除了function拓展外，也可以只用高级函数包裹的方法，可行，但代码量也挺大的。后面在aop的研究中，发现了label对修饰器的支持，这个支持打开了前端aop的大门。修饰器是对函数的加工，同时也可以轻易实现before，after，around等功能，而之前的基本类型拓展也在修饰器下有了一定的解决方案12345@blockDeco()created() &#123; let test=&quot;dsdsdd&quot;; console.log(&quot;create:&quot;+test.test);&#125;; 在before阶段对test属性扩展，在after删除拓展的内容就可以实现这个问题 spring下启动时对类扫描的机制在js中也可以实现，最开始我的想法时静态文件分析的节点有两个，babel和webpack，但其实方向可能有点问题，从静态代码分析怎么放入变量里面呢，这个并不好处理。目前虽然已经实现，但缺少验证，还是等有具体的需求再使用吧","categories":[{"name":"前端架构设计","slug":"前端架构设计","permalink":"http://yoursite.com/categories/前端架构设计/"}],"tags":[]},{"title":"架构设计浅谈","slug":"front-vue","date":"2019-01-14T08:13:10.000Z","updated":"2019-05-09T07:31:08.944Z","comments":true,"path":"2019/01/14/front-vue/","link":"","permalink":"http://yoursite.com/2019/01/14/front-vue/","excerpt":"","text":"设计架构过程中我觉得最最重要的几个问题：1.低耦合2.通用3.拓展性 而对于js来说，低耦合最重要而在开发时我才发现麻烦的问题是让我们没使用过js的小伙伴也能快速上手。于是我的目的是把关键的业务内容尽可能简单的暴露出来，而把实现过程封装了，基本来说就是小伙伴通过简单的对业务配置就能开发中新的业务页面django框架给了我启发，让我通过制定了规则，按照规则进行配置，简单的几句代码就能生成新的页面层级如下： model层根据资源建立model，为每个model对象配置字段属性等1comCode=model.charField(&#123;require:true,fieldName:&quot;单位编号&quot;&#125;) 基本上绝大多数业务都可能通过此配置进行操作，如：1hasCooperate=model.boolField(&#123;require:true,fieldName:&quot;有无合作&quot;,boolSelect:[&quot;不合作&quot;,&quot;合作&quot;],format:(v)=&gt;&#123;return v?&quot;合作&quot;:&quot;不合作&quot;&#125;&#125;) 甚至关联字段也可以如此表现1roles=model.manyToManyField(Role,&#123;require:true,fieldName:&quot;角色&quot;,bindSource:&#123;text:&quot;rname&quot;,value:&quot;id&quot;,parms:&#123;&#125;&#125;&#125;) model解析层将model字段解析成可识别的数据结构 组件层当通过同一规则下面的model，生成对应的基础组件，其中重要包含表单和表格的生成，这一步是最困难的，特别对于处理关联表格的时候，除了对model的字段解析，还需要考虑特殊字段增加情况，而对于特殊情况的处理方式则是使用插槽，model字段和插槽中放入的字段放在一起，其中涉及到了很多细节因素都可能要使功能拓展 缺点：1.当系统后期越来越大时，设计的基本组件就会越来越复杂2.缺少文档的情况下，model的字段类型有点抽象，并且绑定的数据源要考虑的情况很多，比如model一个下拉字段，绑定的数据源就包括自定义数据下拉，资源下拉，资源下拉+自定义数据下拉3.项目中使用的是restful接口，减少了部分变量，如果不是使用restful接口的话，资源模型的实现更加困难","categories":[{"name":"前端架构设计","slug":"前端架构设计","permalink":"http://yoursite.com/categories/前端架构设计/"}],"tags":[]}]}